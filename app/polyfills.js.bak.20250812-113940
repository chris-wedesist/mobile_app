// ========================================================================
// Hermes-safe polyfills for Expo Go (load as the very first import)
// ========================================================================

// Provide a web-like global.self (some libs assume self exists)
if (typeof globalThis !== 'undefined' && typeof globalThis.self === 'undefined') {
  globalThis.self = globalThis;
}

// Basic process/env shim (usually provided by RN, but ensure it's there early)
if (typeof globalThis.process === 'undefined') {
  // @ts-ignore
  globalThis.process = { env: {} };
} else {
  // Ensure env exists
  // @ts-ignore
  globalThis.process.env = globalThis.process.env || {};
}

// Identify runtime for libraries that check navigator.product
if (typeof globalThis.navigator === 'undefined') {
  // @ts-ignore
  globalThis.navigator = {};
}
// @ts-ignore
if (!globalThis.navigator.product) globalThis.navigator.product = 'ReactNative';

// Crypto: getRandomValues (needed by many libs and web crypto polyfills)
import 'react-native-get-random-values';

// URL / URLSearchParams (widely needed by tooling)
import 'react-native-url-polyfill/auto';

// Base64 helpers (atob/btoa)
import { encode as __btoa, decode as __atob } from 'base-64';
if (typeof globalThis.btoa === 'undefined') globalThis.btoa = __btoa;
if (typeof globalThis.atob === 'undefined') globalThis.atob = __atob;

// Buffer polyfill (used by various libs)
if (typeof globalThis.Buffer === 'undefined') {
  try {
    const { Buffer } = require('buffer');
    globalThis.Buffer = Buffer;
  } catch {
    console.warn('Buffer polyfill not available');
  }
}

// TextEncoder/TextDecoder polyfill (Hermes-friendly)
// Use a manual polyfill that's guaranteed to work with Hermes
if (typeof globalThis.TextEncoder === 'undefined' || typeof globalThis.TextDecoder === 'undefined') {
  try {
    // Simple TextEncoder/TextDecoder for Hermes
    globalThis.TextEncoder = class TextEncoder {
      encoding = 'utf-8';
      encode(input = '') {
        // Convert string to Uint8Array
        const bytes = [];
        for (let i = 0; i < input.length; i++) {
          const code = input.charCodeAt(i);
          if (code < 0x80) {
            bytes.push(code);
          } else if (code < 0x800) {
            bytes.push(0xc0 | (code >> 6));
            bytes.push(0x80 | (code & 0x3f));
          } else if (code < 0x10000) {
            bytes.push(0xe0 | (code >> 12));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
          }
        }
        return new Uint8Array(bytes);
      }
    };

    globalThis.TextDecoder = class TextDecoder {
      encoding = 'utf-8';
      constructor(encoding) {
        this.encoding = encoding || 'utf-8';
      }
      decode(input) {
        if (!input) return '';
        let result = '';
        const bytes = new Uint8Array(input);
        for (let i = 0; i < bytes.length; i++) {
          result += String.fromCharCode(bytes[i]);
        }
        return result;
      }
    };
  } catch (e) {
    console.warn('Failed to create TextEncoder/TextDecoder polyfill:', e);
  }
}

// Ensure globalThis.window references globalThis (avoid web-target checks failing)
if (typeof globalThis.window === 'undefined') {
  // @ts-ignore
  globalThis.window = globalThis;
}
